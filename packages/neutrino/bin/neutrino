#!/usr/bin/env node

// TODO: Remove this once babel-loader updates
// https://github.com/babel/babel-loader/pull/391
process.noDeprecation = true;

const yargs = require('yargs');
const { map, pipe } = require('ramda');
const { join } = require('path');
const { fork } = require('child_process');
const { req, toArray, normalizeConfig } = require('../src/utils');

const cwd = process.cwd();
const args = yargs
  .option('inspect', {
    description: 'Output a string representation of the configuration used by webpack and exit',
    boolean: true,
    default: false,
    global: true
  })
  .option('use', {
    description: 'A list of Neutrino middleware used to configure the build',
    array: true,
    default: [],
    global: true
  })
  .option('options', {
    description: 'Set Neutrino options, config, and environment variables, e.g. --options.env.NODE_ENV production',
    default: {},
    global: true
  })
  .option('quiet', {
    description: 'Disable console output of CLI commands',
    boolean: true,
    default: false,
    global: true
  })
  .option('debug', {
    description: 'Run in debug mode',
    boolean: true,
    default: false,
    global: true
  })
  .option('require', {
    description: 'Preload a module prior to loading Neutrino; can be used multiple times',
    array: true,
    default: [],
    global: true
  })
  .command('start', 'Build a project in development mode')
  .command('build', 'Compile the source directory to a bundled build')
  .command('test [files..]', 'Run all suites from the test directory or provided files', {
    coverage: {
      description: 'Collect test coverage information and generate report',
      boolean: true,
      default: false
    },
    watch: {
      description: 'Watch source files for changes and re-run tests',
      boolean: true,
      default: false
    }
  })
  .command('*')
  .demandCommand(1, 'You must specify a command for Neutrino to run.\nUSAGE:  neutrino <command>')
  .recommendCommands()
  .argv;

const rc = '.neutrinorc.js';
const hasRc = () => {
  try {
    require.resolve(join(process.cwd(), rc));
    return true;
  } catch (err) {
    return false;
  }
};
const coreCommands = ['build', 'start', 'test', 'inspect'];
const mergeConfig = ({ config }) => config.merge(args.options.config);
const cmd = args.inspect ? 'inspect' : args._[0];
const rawConfigs = hasRc() ?
  toArray(req('.neutrinorc.js', process.cwd())) :
  [[...new Set(args.use)]];

if (!rawConfigs.length) {
  throw new Error('No middleware was found. Specify middleware with --use or create a .neutrinorc.js file.');
}

const configs = map(pipe(
  normalizeConfig,
  // Merge CLI config options as last piece of middleware, e.g. options.config.devServer.port 4000
  (config) => {
    if (args.options) {
      config.use.push(mergeConfig);
    }

    return config;
  }
), rawConfigs);

process.on('unhandledRejection', (err) => {
  if (!args.quiet) {
    console.error('');
    console.error(err);
  }

  process.exit(1);
});

const promises = map((moduleId) => {
  const module = req(moduleId, cwd);

  return typeof module === 'function' ? module() : module;
}, args.require);
const processes = [];

process.on('SIGINT', (...args) => {
  processes.forEach(process => process.kill(...args));
});

Promise
  .all(promises)
  .then(() => {
    configs.forEach((middleware) => {
      const script = join(__dirname, coreCommands.includes(cmd) ? `./${cmd}` : './execute');
      const child = fork(script);

      child.on('exit', (code) => {
        process.exit(code);
        processes.forEach(process => process !== child && process.kill(code));
      });
      child.send([middleware, args]);
      processes.push(child);
    });
  });
